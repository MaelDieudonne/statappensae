```{r include=FALSE}
# Importation des données
mca_data <- load_parquet("mca_data.parquet")
detailed_mca_data <- load_parquet("detailed_mca_data.parquet")
map_data <- load_shapefile("FRANCE.shx")

codes_regions <- fread("data_other/codes_regions_Insee.csv", header = TRUE)
codes_regions$ABRV <- sapply(codes_regions$LIBELLE, get_first_letters)
```

```{r}
# Définition des variables
## Outcomes
mca_relative_outcomes <- c("part_T1", "part_T2", "GD_ratio_T1", "EC_ratio_T1", "EC_ratio_T2")
mca_absolute_outcomes <- c("part_T1", "part_T2", "DIns_ratio_T1", "GIns_ratio_T2", "DIns_ratio_T2", "EIns_ratio_T1", "CIns_ratio_T1", "EIns_ratio_T2", "CIns_ratio_T2")
mca_detailed_outcomes <- grep("^pvoix", names(detailed_mca_data), value = TRUE)

## Régresseurs
mca_regressors <- c("ppropri", "popcomm", "popagglo", "pinscript", "age", "prop1539", "prop4059", "prop60p", "propf", "propbac", "propsup", "pagri", "pindp", "pcadr", "ppint", "pempl", "pchom", "petranger", "revmoy", "pcrimesdelits", "mmoyfortune", "pisf", "prsa", "type_comm")
### Régresseurs abandonnés pour complaire aux économètres : prefract1791, pclerge1791, pclerge1856, pmessalisants1950
```

**Analyses descriptives**

Tableau récapitulatif (dont valeurs manquantes)

```{r}
nb_communes <- uniqueN(mca_data, by = "codecommune")

# Initialisation et calcul des valeurs
stat_desc <- data.table()
for (col in names(mca_data)) {if (!(col %in% c("dep", "codecommune", "codecommune2", "year", "GD_ratio_T2", "GIns_ratio_T2"))) {
  summary <- mca_data[, {
    fivenum_values <- fivenum(get(col))
    nan_count <- sum(is.na(get(col)))
    nan_count_prop <- round(100 * nan_count / nb_communes, 2)
    nan_pop <- sum(popcomm[is.na(get(col))], na.rm = TRUE)
    data.table(
      Variable = col,
      "Min" = round(fivenum_values[1], 0),
      "1er quartile" = fivenum_values[2],
      "Mediane" = fivenum_values[3],
      "3e quartile" = fivenum_values[4],
      "Max" = fivenum_values[5],
      "Valeurs manquantes" = nan_count,
      "En % des communes" = nan_count_prop
    )
  }]
stat_desc <- rbind(stat_desc, summary)
}}

stat_desc[] <- data.frame(lapply(stat_desc, tidy_table))
print(xtable(stat_desc, type = "latex"), file = "output/stat_desc_acm.tex")
print(stat_desc)

# Nettoyage
rm(col, nb_communes, stat_desc, summary)
```

Corrélogramme

```{r include=FALSE}
corr_variables <- c(mca_regressors, mca_relative_outcomes)
mca_corr_data <- mca_data[, ..corr_variables, with = FALSE]

mca_corr_data <- mca_corr_data[, .SD, .SDcols = sapply(mca_corr_data, is.numeric)]
mca_corr_data <- mca_corr_data[complete.cases(mca_corr_data)]

correlation_matrix <- cor(mca_corr_data)

png(filename = "output/corrplot.png", width = 2200, height = 1800)
corrplot(
  correlation_matrix,
  type = "upper",
  method = "color",
  order = "FPC",
  tl.cex = 3.5,
  tl.srt = 60,
  tl.col = "darkgrey",
  cl.cex = 3.5
)
dev.off()

rm(corr_variables, correlation_matrix, mca_corr_data)
```

Cartes ?

**Régression**

Pour comparer avec les coefficients obtenus sur les données de panel. Les se sont calculées avec clustering départemental, mais cela ne semble pas les affecter.

```{r include=FALSE}
# Pour traiter le type de commune comme une variable catégorielle. Pour mémoire :
## 1 = villages (agglos <2000 hab)
## 2 = bourgs (agglos >2000 et <100 000 hab)
## 3 = banlieues (communes secondaires agglos >100 000 hab)
## 4 = métropoles (communes principales agglos >100 000 hab)
mca_data$type_comm <- factor(mca_data$type_comm)

relative_results <- list()
for (outcome in mca_relative_outcomes) {
  regression_formula <- as.formula(paste(outcome, "~", paste(mca_regressors, collapse = "+")))
  model_name <- paste0(outcome, "_model")
  relative_results[[model_name]] <- lm.cluster(regression_formula, data = mca_data, cluster = "dep")
}
suppressWarnings(
  stargazer(relative_results, type = "html", out = "output/2017_relative_results.html")
)

relative_results <- list()
for (outcome in mca_absolute_outcomes) {
  regression_formula <- as.formula(paste(outcome, "~", paste(mca_regressors, collapse = "+")))
  model_name <- paste0(outcome, "_model")
  relative_results[[model_name]] <- lm.cluster(regression_formula, data = mca_data, cluster = "dep")
}
suppressWarnings(
  stargazer(relative_results, type = "html", out = "output/2017_absolute_results.html")
)

rm(model_name, outcome, regression_formula)
```

**ACP**

Est-ce que le code normalise vraiment les variables ?
The scale function standardizes the values in each column (i.e., it subtracts the mean and divides by the standard deviation).

```{r}
# Sélection des variables
## On ajoute les modalités éliminées pour éviter la colinéarité dans les régressions.
## On supprime les valeurs manquantes.
variables_of_interest <- c(mca_regressors, "prop014", "propnodip", "pouvr", mca_detailed_outcomes)
mca_data_subset <- detailed_mca_data[, ..variables_of_interest]
mca_data_subset <- na.omit(mca_data_subset)

# On normalise les variables numériques
mca_data_subset[, names(mca_data_subset)[sapply(mca_data_subset, is.numeric)] := lapply(.SD, scale), .SDcols = names(mca_data_subset)]

# Création d'indicatrices pour les types de communes
mca_data_subset$type_comm <- as.factor(mca_data_subset$type_comm)
dummies <- model.matrix(~ type_comm - 1, data = mca_data_subset)
colnames(dummies) <- paste("type_comm", levels(mca_data_subset$type_comm), sep = "_")
mca_data_subset <- cbind(mca_data_subset, dummies)
mca_data_subset$type_comm <- NULL

# Analyse
result <- PCA(mca_data_subset, graph = TRUE)
fviz_screeplot(result, addlabels = TRUE, ylim = c(0, 50))
print(result$var$contrib)

# Nettoyage
rm(dummies, mca_data_subset, result, variables_of_interest)
```
